/*
 * Copyright 2025 The Ansible plugin Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import express from 'express';
import Router from 'express-promise-router';
import type { Config } from '@backstage/config';

import { AAPJobTemplateProvider } from './providers/AAPJobTemplateProvider';
import { AAPEntityProvider } from './providers/AAPEntityProvider';
import { LoggerService } from '@backstage/backend-plugin-api';
import { EEEntityProvider } from './providers/EEEntityProvider';
import { PAHCollectionProvider } from './providers/PAHCollectionProvider';
import { AnsibleGitContentsProvider } from './providers/AnsibleGitContentsProvider';
import {
  SyncFilter,
  parseSourceId,
  findMatchingProviders,
  validateSyncFilter,
  SyncStatus,
  SyncResultStatus,
  SCMSyncResult,
} from './helpers';
import { ScmClientFactory } from '@ansible/backstage-rhaap-common';

export async function createRouter(options: {
  logger: LoggerService;
  config: Config;
  aapEntityProvider: AAPEntityProvider;
  jobTemplateProvider: AAPJobTemplateProvider;
  eeEntityProvider: EEEntityProvider;
  pahCollectionProviders: PAHCollectionProvider[];
  ansibleGitContentsProviders?: AnsibleGitContentsProvider[];
}): Promise<express.Router> {
  const {
    logger,
    config,
    aapEntityProvider,
    jobTemplateProvider,
    eeEntityProvider,
    pahCollectionProviders,
    ansibleGitContentsProviders = [],
  } = options;
  const router = Router();
  const scmClientFactory = new ScmClientFactory({ rootConfig: config, logger });

  const _PAH_PROVIDERS = new Map<string, PAHCollectionProvider>();
  for (const provider of pahCollectionProviders) {
    _PAH_PROVIDERS.set(provider.getPahRepositoryName(), provider);
  }

  const _GIT_CONTENTS_PROVIDERS = new Map<string, AnsibleGitContentsProvider>();
  for (const provider of ansibleGitContentsProviders) {
    _GIT_CONTENTS_PROVIDERS.set(provider.getSourceId(), provider);
  }

  router.get('/health', (_, response) => {
    logger.info('PONG!');
    response.json({ status: 'ok' });
  });

  router.get('/aap/sync_orgs_users_teams', async (_, response) => {
    logger.info('Starting orgs, users and teams sync');
    const res = await aapEntityProvider.run();
    response.status(200).json(res);
  });

  router.get('/aap/sync_job_templates', async (_, response) => {
    logger.info('Starting job templates sync');
    const res = await jobTemplateProvider.run();
    response.status(200).json(res);
  });

  router.get('/ansible/sync/status', async (request, response) => {
    logger.info('Getting sync status');
    const aapEntities = request.query.aap_entities === 'true';
    const ansibleContents = request.query.ansible_contents === 'true';
    const noQueryParams =
      request.query.aap_entities === undefined &&
      request.query.ansible_contents === undefined;

    try {
      const result: {
        aap?: {
          orgsUsersTeams: { lastSync: string | null };
          jobTemplates: { lastSync: string | null };
        };
        content?: {
          syncInProgress: boolean;
          providers: Array<{
            sourceId: string;
            repository?: string;
            scmProvider?: string;
            hostName?: string;
            organization?: string;
            providerName: string;
            enabled: boolean;
            syncInProgress: boolean;
            lastSyncTime: string | null;
            lastFailedSyncTime: string | null;
            lastSyncStatus: 'success' | 'failure' | null;
            collectionsFound: number;
            collectionsDelta: number;
          }>;
        };
      } = {};

      // Include aap block if aap_entities=true or no query params
      if (aapEntities || noQueryParams) {
        result.aap = {
          orgsUsersTeams: {
            lastSync: aapEntityProvider.getLastSyncTime(),
          },
          jobTemplates: {
            lastSync: jobTemplateProvider.getLastSyncTime(),
          },
        };
      }

      if (ansibleContents || noQueryParams) {
        const pahProviders = pahCollectionProviders.map(provider => ({
          sourceId: provider.getSourceId(),
          repository: provider.getPahRepositoryName(),
          providerName: provider.getProviderName(),
          enabled: provider.isEnabled(),
          syncInProgress: provider.getIsSyncing(),
          lastSyncTime: provider.getLastSyncTime(),
          lastFailedSyncTime: provider.getLastFailedSyncTime(),
          lastSyncStatus: provider.getLastSyncStatus(),
          collectionsFound: provider.getCurrentCollectionsCount(),
          collectionsDelta: provider.getCollectionsDelta(),
        }));
        const scmProviders = ansibleGitContentsProviders.map(provider => {
          const providerInfo = parseSourceId(provider.getSourceId());
          return {
            sourceId: provider.getSourceId(),
            scmProvider: providerInfo.scmProvider,
            hostName: providerInfo.hostName,
            organization: providerInfo.organization,
            providerName: provider.getProviderName(),
            enabled: provider.isEnabled(),
            syncInProgress: provider.getIsSyncing(),
            lastSyncTime: provider.getLastSyncTime(),
            lastFailedSyncTime: provider.getLastFailedSyncTime(),
            lastSyncStatus: provider.getLastSyncStatus(),
            collectionsFound: provider.getCurrentCollectionsCount(),
            collectionsDelta: provider.getCollectionsDelta(),
          };
        });
        const providers = [...pahProviders, ...scmProviders];
        const anySyncInProgress = providers.some(p => p.syncInProgress);

        result.content = {
          syncInProgress: anySyncInProgress,
          providers,
        };
      }

      response.status(200).json(result);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      logger.error(`Failed to get sync status: ${errorMessage}`);

      response.status(500).json({
        error: `Failed to get sync status: ${errorMessage}`,
        aap: {
          orgsUsersTeams: null,
          jobTemplates: null,
        },
        content: null,
      });
    }
  });

  router.post('/aap/create_user', express.json(), async (request, response) => {
    const { username, userID } = request.body;
    if (!username || userID === undefined || userID === null) {
      response
        .status(400)
        .json({ error: 'Missing username and user id in request body.' });
      return;
    }

    logger.info(`Creating user ${username} in catalog`);
    try {
      const res = await aapEntityProvider.createSingleUser(username, userID);
      response
        .status(200)
        .json({ success: true, user: username, created: res });
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      logger.error(`Failed to create user ${username}: ${errorMessage}`);
      response
        .status(500)
        .json({ error: `Failed to create user: ${errorMessage}` });
    }
  });

  router.post('/register_ee', express.json(), async (request, response) => {
    const { entity } = request.body;

    if (!entity) {
      response.status(400).json({ error: 'Missing entity in request body.' });
      return;
    }

    try {
      await eeEntityProvider.registerExecutionEnvironment(entity);
      response.status(200).json({ success: true });
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      logger.error(`Failed to register Execution Environment: ${errorMessage}`);
      response.status(500).json({
        error: `Failed to register Execution Environment: ${errorMessage}`,
      });
    }
  });

  router.post(
    '/ansible/sync/from-aap/content',
    express.json(),
    async (request, response) => {
      // Extract repository names from request body
      // Expected format: { "filters": [{ "repository_name": "rh-certified" }, { "repository_name": "validated" }] }
      const { filters } = request.body as {
        filters?: Array<{ repository_name: string }>;
      };

      let repositoryNames: string[];
      if (!filters || filters.length === 0) {
        // if no filters provided, assume all repositories should be synced
        repositoryNames = [];
      } else {
        // extract repository_name from each filter object
        repositoryNames = filters
          .map(f => f.repository_name)
          .filter(
            (name): name is string =>
              typeof name === 'string' && name.length > 0,
          );
      }

      // Separate valid and invalid repository names
      const invalidRepositories: string[] = [];
      let providersToRun: PAHCollectionProvider[];

      if (repositoryNames.length > 0) {
        // Filter out invalid repositories but don't fail the request
        const validNames: string[] = [];
        for (const name of repositoryNames) {
          if (_PAH_PROVIDERS.has(name)) {
            validNames.push(name);
          } else {
            invalidRepositories.push(name);
          }
        }
        providersToRun = validNames.map(name => _PAH_PROVIDERS.get(name)!);
      } else {
        // if no filters provided, run all providers
        providersToRun = pahCollectionProviders;
      }

      logger.info(
        `Starting PAH collections sync for repository name(s): ${
          providersToRun.length > 0
            ? providersToRun.map(p => p.getPahRepositoryName()).join(', ')
            : 'none'
        }`,
      );

      interface PAHSyncResult {
        repositoryName: string;
        providerName?: string;
        status: SyncResultStatus;
        error?: { code: string; message: string };
      }

      const results: PAHSyncResult[] = providersToRun.map(provider => {
        const repositoryName = provider.getPahRepositoryName();
        const providerName = provider.getProviderName();

        const { started, skipped, error } = provider.startSync();

        if (skipped) {
          logger.info(
            `Skipping sync for ${repositoryName}: sync already in progress`,
          );
          return {
            repositoryName,
            providerName,
            status: 'already_syncing' as SyncResultStatus,
          };
        }

        if (!started) {
          logger.error(
            `Failed to start sync for ${repositoryName}: ${
              error ?? 'unknown error'
            }`,
          );
          return {
            repositoryName,
            providerName,
            status: 'failed' as SyncResultStatus,
            error: {
              code: 'SYNC_START_FAILED',
              message: error ?? 'Failed to initiate sync for provider',
            },
          };
        }

        return {
          repositoryName,
          providerName,
          status: 'sync_started' as SyncResultStatus,
        };
      });

      for (const invalidRepo of invalidRepositories) {
        results.push({
          repositoryName: invalidRepo,
          status: 'invalid' as SyncResultStatus,
          error: {
            code: 'INVALID_REPOSITORY',
            message: `Repository '${invalidRepo}' not found in configured providers`,
          },
        });
      }

      const summary: SyncStatus & { total: number } = {
        total: results.length,
        sync_started: results.filter(r => r.status === 'sync_started').length,
        already_syncing: results.filter(r => r.status === 'already_syncing')
          .length,
        failed: results.filter(r => r.status === 'failed').length,
        invalid: results.filter(r => r.status === 'invalid').length,
      };

      const hasFailures = results.some(r => r.status === 'failed');
      const hasStarted = results.some(r => r.status === 'sync_started');
      const hasInvalid = results.some(r => r.status === 'invalid');
      const allStarted =
        results.length > 0 && results.every(r => r.status === 'sync_started');
      const allSkipped =
        results.length > 0 &&
        results.every(r => r.status === 'already_syncing');
      const allFailed =
        results.length > 0 && results.every(r => r.status === 'failed');
      const allInvalid =
        results.length > 0 && results.every(r => r.status === 'invalid');
      const emptyRequest =
        repositoryNames.length === 0 && pahCollectionProviders.length === 0;

      let statusCode: number;
      if (
        allInvalid ||
        emptyRequest ||
        (hasInvalid && hasFailures && !hasStarted)
      ) {
        statusCode = 400;
      } else if (allFailed) {
        statusCode = 500;
      } else if (allStarted) {
        statusCode = 202;
      } else if (allSkipped) {
        statusCode = 200;
      } else {
        statusCode = 207;
      }

      response.status(statusCode).json({
        summary,
        results,
      });
    },
  );

  function getProvidersFromFilters(
    filters: SyncFilter[],
  ): AnsibleGitContentsProvider[] {
    const matchedIds = findMatchingProviders(
      ansibleGitContentsProviders,
      filters,
    );
    return Array.from(matchedIds).map(id => _GIT_CONTENTS_PROVIDERS.get(id)!);
  }

  // SCM-based content sync with hierarchical filtering
  router.post(
    '/ansible/sync/from-scm/content',
    express.json(),
    async (request, response) => {
      const { filters = [] } = request.body as { filters?: SyncFilter[] };
      const invalidFilters: Array<{ filter: SyncFilter; error: string }> = [];
      for (const filter of filters) {
        const validationError = validateSyncFilter(filter);
        if (validationError) {
          invalidFilters.push({ filter, error: validationError });
        }
      }

      const validFilters = filters.filter(
        f => !invalidFilters.some(inv => inv.filter === f),
      );
      const providersToSync =
        filters.length === 0
          ? ansibleGitContentsProviders
          : getProvidersFromFilters(validFilters);

      logger.info(
        `Starting Ansible Git Contents sync for ${
          providersToSync.length > 0
            ? providersToSync.map(p => p.getSourceId()).join(', ')
            : 'none'
        }`,
      );

      const results: SCMSyncResult[] = providersToSync.map(provider => {
        const sourceId = provider.getSourceId();
        const providerName = provider.getProviderName();
        const { scmProvider, hostName, organization } = parseSourceId(sourceId);

        const { started, skipped, error } = provider.startSync();

        if (skipped) {
          logger.info(
            `Skipping sync for ${sourceId}: sync already in progress`,
          );
          return {
            scmProvider,
            hostName,
            organization,
            providerName,
            status: 'already_syncing' as SyncResultStatus,
          };
        }

        if (!started) {
          logger.error(
            `Failed to start sync for ${sourceId}: ${error ?? 'unknown error'}`,
          );
          return {
            scmProvider,
            hostName,
            organization,
            providerName,
            status: 'failed' as SyncResultStatus,
            error: {
              code: 'SYNC_START_FAILED',
              message: error ?? 'Failed to initiate sync for provider',
            },
          };
        }

        return {
          scmProvider,
          hostName,
          organization,
          providerName,
          status: 'sync_started' as SyncResultStatus,
        };
      });

      for (const { filter, error } of invalidFilters) {
        results.push({
          scmProvider: filter.scmProvider || '',
          hostName: filter.hostName || '',
          organization: filter.organization || '',
          status: 'invalid' as SyncResultStatus,
          error: {
            code: 'INVALID_FILTER',
            message: error,
          },
        });
      }

      const summary: SyncStatus & { total: number } = {
        total: results.length,
        sync_started: results.filter(r => r.status === 'sync_started').length,
        already_syncing: results.filter(r => r.status === 'already_syncing')
          .length,
        failed: results.filter(r => r.status === 'failed').length,
        invalid: results.filter(r => r.status === 'invalid').length,
      };

      const hasFailures = results.some(r => r.status === 'failed');
      const hasStarted = results.some(r => r.status === 'sync_started');
      const hasInvalid = results.some(r => r.status === 'invalid');
      const allStarted =
        results.length > 0 && results.every(r => r.status === 'sync_started');
      const allSkipped =
        results.length > 0 &&
        results.every(r => r.status === 'already_syncing');
      const allFailed =
        results.length > 0 && results.every(r => r.status === 'failed');
      const allInvalid =
        results.length > 0 && results.every(r => r.status === 'invalid');
      const emptyRequest =
        filters.length === 0 && ansibleGitContentsProviders.length === 0;

      let statusCode: number;
      if (
        allInvalid ||
        emptyRequest ||
        (hasInvalid && hasFailures && !hasStarted)
      ) {
        statusCode = 400;
      } else if (allFailed) {
        statusCode = 500;
      } else if (allStarted) {
        statusCode = 202;
      } else if (allSkipped) {
        statusCode = 200;
      } else {
        statusCode = 207;
      }

      response.status(statusCode).json({
        summary,
        results,
      });
    },
  );

  router.get('/git_readme_content', async (request, response) => {
    const { scmProvider, host, owner, repo, filePath, ref } = request.query;

    const required = [
      'scmProvider',
      'host',
      'owner',
      'repo',
      'filePath',
      'ref',
    ];
    const missing = required.filter(p => !request.query[p]);
    if (missing.length > 0) {
      response.status(400).json({
        error: `Missing required query parameters: ${missing.join(', ')}`,
      });
      return;
    }

    const scm = (scmProvider as string).toLowerCase();
    const hostUrl = host as string;
    const ownerName = owner as string;
    const repoName = repo as string;
    const path = filePath as string;
    const refName = ref as string;

    if (!['github', 'gitlab'].includes(scm)) {
      response.status(400).json({
        error: `Unsupported SCM provider '${scm}'. Supported: github, gitlab`,
      });
      return;
    }

    logger.info(
      `Fetching README from ${scm}://${hostUrl}/${ownerName}/${repoName}/${path}@${refName}`,
    );

    try {
      const scmClient = await scmClientFactory.createClient({
        scmProvider: scm as 'github' | 'gitlab',
        host: hostUrl,
        organization: ownerName,
      });

      const content = await scmClient.getFileContent(
        {
          name: repoName,
          fullPath: `${ownerName}/${repoName}`,
          defaultBranch: refName,
          url: `https://${hostUrl}/${ownerName}/${repoName}`,
        },
        refName,
        path,
      );

      response.type('text/markdown');
      response.send(content);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      logger.warn(`Failed to fetch README: ${errorMessage}`);

      const status = errorMessage.includes('not found') ? 404 : 500;
      response.status(status).json({
        error: `Failed to fetch README: ${errorMessage}`,
      });
    }
  });

  return router;
}
