import {
  createContext,
  useContext,
  useState,
  useCallback,
  useMemo,
  useRef,
  ReactNode,
} from 'react';
import {
  Notification,
  NotificationContextValue,
  ShowNotificationOptions,
} from './types';

const generateId = (): string => {
  return `notif-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
};

const DEFAULT_AUTO_HIDE_DURATIONS: Record<string, number> = {
  info: 15000,
  success: 15000,
  warning: 15000,
  error: 0,
};

const EXIT_ANIMATION_DURATION = 300;

const NotificationContext = createContext<NotificationContextValue | undefined>(
  undefined,
);

interface NotificationProviderProps {
  children: ReactNode;
}

export const NotificationProvider = ({
  children,
}: NotificationProviderProps) => {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const autoHideTimeoutsRef = useRef<Map<string, NodeJS.Timeout>>(new Map());

  const startExitAnimation = useCallback((id: string) => {
    setNotifications(prev =>
      prev.map(n => (n.id === id ? { ...n, isExiting: true } : n)),
    );

    setTimeout(() => {
      setNotifications(prev => prev.filter(n => n.id !== id));
    }, EXIT_ANIMATION_DURATION);
  }, []);

  const showNotification = useCallback(
    (options: ShowNotificationOptions): string => {
      const id = generateId();
      const severity = options.severity ?? 'info';
      const autoHideDuration =
        options.autoHideDuration ??
        DEFAULT_AUTO_HIDE_DURATIONS[severity] ??
        15000;

      const newNotification: Notification = {
        id,
        title: options.title,
        description: options.description,
        items: options.items,
        severity,
        collapsible: options.collapsible ?? false,
        category: options.category,
        timestamp: new Date(),
        autoHideDuration,
        isExiting: false,
      };

      setNotifications(prev => {
        if (options.dismissCategories && options.dismissCategories.length > 0) {
          prev
            .filter(
              n =>
                options.dismissCategories!.includes(n.category!) &&
                !n.isExiting,
            )
            .forEach(n => {
              const timeout = autoHideTimeoutsRef.current.get(n.id);
              if (timeout) {
                clearTimeout(timeout);
                autoHideTimeoutsRef.current.delete(n.id);
              }
            });
        }

        const updated =
          options.dismissCategories && options.dismissCategories.length > 0
            ? prev.map(n =>
                options.dismissCategories!.includes(n.category!) && !n.isExiting
                  ? { ...n, isExiting: true }
                  : n,
              )
            : prev;

        return [...updated, newNotification];
      });

      if (options.dismissCategories && options.dismissCategories.length > 0) {
        setTimeout(() => {
          setNotifications(prev =>
            prev.filter(n => !options.dismissCategories!.includes(n.category!)),
          );
        }, EXIT_ANIMATION_DURATION);
      }

      if (autoHideDuration > 0) {
        const timeout = setTimeout(() => {
          autoHideTimeoutsRef.current.delete(id);
          startExitAnimation(id);
        }, autoHideDuration);
        autoHideTimeoutsRef.current.set(id, timeout);
      }

      return id;
    },
    [startExitAnimation],
  );

  const removeNotification = useCallback(
    (id: string) => {
      const timeout = autoHideTimeoutsRef.current.get(id);
      if (timeout) {
        clearTimeout(timeout);
        autoHideTimeoutsRef.current.delete(id);
      }
      startExitAnimation(id);
    },
    [startExitAnimation],
  );

  const clearAll = useCallback(() => {
    autoHideTimeoutsRef.current.forEach(timeout => clearTimeout(timeout));
    autoHideTimeoutsRef.current.clear();
    setNotifications([]);
  }, []);

  const contextValue = useMemo<NotificationContextValue>(
    () => ({
      notifications,
      showNotification,
      removeNotification,
      clearAll,
    }),
    [notifications, showNotification, removeNotification, clearAll],
  );

  return (
    <NotificationContext.Provider value={contextValue}>
      {children}
    </NotificationContext.Provider>
  );
};

export const useNotifications = (): NotificationContextValue => {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error(
      'useNotifications must be used within a NotificationProvider',
    );
  }
  return context;
};
